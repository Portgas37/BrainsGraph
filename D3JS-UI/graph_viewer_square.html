<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>JSON Graph Viewer - Tree Layout</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            color: #333;
        }

        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            max-width: 280px;
            font-size: 11px;
        }
        .button-group {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        button {
            padding: 6px 10px;
            background: #666;
            border: none;
            border-radius: 3px;
            color: white;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        button:hover {
            background: #555;
        }

        button:active {
            background: #444;
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }


        #graph {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* --- NODE STYLES (RECTANGLES) --- */
        .node {
            cursor: pointer;
        }

        .node rect {
            stroke: #666;
            stroke-width: 2px;
            fill: #ffffff;
            rx: 6px; /* Rounded corners */
            ry: 6px;
            transition: all 0.2s;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.1));
        }

        .node:hover rect {
            fill: #f0f0f0;
            stroke: #333;
            stroke-width: 3px;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));
        }

        /* Types */
        .node.enum rect { fill: #f0f0f0; stroke: #888; }
        .node.interface rect { stroke-dasharray: 4,2; fill: #fafafa; }
        .node.abstract rect { stroke-dasharray: 6,3; fill: #f5f5f5; }

        /* Highlight styles applied to the rect */
        .node.highlighted rect { stroke-width: 3px !important; }
        
        .node.highlight-1 rect { fill: #ffd93d !important; stroke: #ff6b6b !important; }
        .node.highlight-2 rect { fill: #a8e6cf !important; stroke: #3cb371 !important; }
        .node.highlight-3 rect { fill: #ff9ff3 !important; stroke: #da70d6 !important; }
        .node.highlight-4 rect { fill: #feca57 !important; stroke: #ee5a24 !important; }
        .node.highlight-5 rect { fill: #48dbfb !important; stroke: #0abde3 !important; }
        .node.highlight-6 rect { fill: #ff6348 !important; stroke: #e74c3c !important; }
        .node.highlight-7 rect { fill: #dfe6e9 !important; stroke: #636e72 !important; }
        .node.highlight-8 rect { fill: #a29bfe !important; stroke: #6c5ce7 !important; }
        .node.highlight-9 rect { fill: #fd79a8 !important; stroke: #e84393 !important; }
        .node.highlight-10 rect { fill: #00b894 !important; stroke: #00cec9 !important; }

        .link {
            fill: none;
            stroke: #999;
            stroke-width: 2px;
            opacity: 0.6;
        }

        .link.contains { stroke: #666; stroke-width: 2.5px; }
        .link.uses { stroke: #aaa; stroke-dasharray: 5,5; }
        .link.references { stroke: #888; stroke-dasharray: 8,4; }
        .link.inherits { stroke: #666; stroke-width: 2px; }

        .link.highlighted {
            stroke-width: 4px !important;
            opacity: 1;
        }

        /* Link Highlights */
        .link.highlight-1 { stroke: #ff6b6b !important; }
        .link.highlight-2 { stroke: #3cb371 !important; }
        .link.highlight-3 { stroke: #da70d6 !important; }
        .link.highlight-4 { stroke: #ee5a24 !important; }
        .link.highlight-5 { stroke: #0abde3 !important; }
        .link.highlight-6 { stroke: #e74c3c !important; }
        .link.highlight-7 { stroke: #636e72 !important; }
        .link.highlight-8 { stroke: #6c5ce7 !important; }
        .link.highlight-9 { stroke: #e84393 !important; }
        .link.highlight-10 { stroke: #00cec9 !important; }

        .label {
            font-size: 11px;
            font-weight: 600;
            pointer-events: none;
            text-anchor: middle;
            fill: #333;
            user-select: none;
            dominant-baseline: middle;
        }

        .link-label {
            font-size: 9px;
            fill: #666;
            pointer-events: none;
            user-select: none;
            background: white;
        }

        .tooltip {
            position: fixed;
            background: rgba(255, 255, 255, 0.98);
            border: 2px solid #666;
            border-radius: 8px;
            padding: 15px;
            pointer-events: none;
            z-index: 2000;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            font-size: 13px;
            line-height: 1.5;
        }

        .tooltip-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 2px solid #ddd;
        }

        .tooltip-stereotype {
            font-size: 11px;
            color: #666;
            font-style: italic;
            margin-bottom: 5px;
        }

        .tooltip-section { margin-top: 10px; }
        .tooltip-section-title {
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tooltip-member {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            color: #444;
            padding: 2px 0;
            padding-left: 10px;
        }

        .tooltip-member.function, .tooltip-member.method { color: #2d7a3e; }
        .tooltip-member.private { color: #c53030; }
        .tooltip-member.public { color: #2d7a3e; }
        .tooltip-member.protected { color: #b7791f; }

        #info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            font-size: 15px;
            color: #666;
            min-width: 300px;
            line-height: 1.6;
        }

        #legend {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            font-size: 13px;
            max-width: 350px;
            line-height: 1.6;
        }

        .error { color: #d32f2f; font-weight: 500; margin-top: 10px; }

        .highlight-badge {
            display: inline-block;
            background: #ff6b6b;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 8px;
        }
    </style>
</head>
<body>
<div id="controls">
    <div class="button-group">
        <button class="icon-btn" onclick="renderGraph(currentData)" title="Reset Layout">üîÑ</button>
        <button class="icon-btn" onclick="centerGraph()" title="Center">üéØ</button>
        <button class="icon-btn" onclick="changeLayout()" title="Change Direction">‚ÜîÔ∏è</button>
    </div>
    <div style="margin-top: 8px; font-size: 11px; color: #666; font-weight: 600;">
        <span id="layoutMode">LR</span>
    </div>
    <div id="error"></div>
</div>

<div id="info">
    <div>Drop a .json file to visualize</div>
    <div id="stats"></div>
</div>

<div id="legend">
    <h3 style="margin: 0 0 12px 0; font-size: 15px; color: #333; border-bottom: 2px solid #ddd; padding-bottom: 8px; font-weight: bold;">
        Legend
    </h3>
    <div style="margin-bottom: 12px;">
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <div style="width: 20px; height: 20px; background: #ffd93d; border: 3px solid #ff6b6b; border-radius: 4px;"></div>
            <div style="font-size: 13px; color: #444; font-weight: 500;">Highlighted Node</div>
        </div>
        <div style="display: flex; align-items: center; gap: 10px;">
            <div style="width: 40px; height: 4px; background: #ff6b6b; box-shadow: 0 0 6px rgba(255,107,107,0.8);"></div>
            <div style="font-size: 13px; color: #444; font-weight: 500;">Highlighted Path</div>
        </div>
    </div>
    <div id="colorGroupsLegend" style="margin-top: 12px;"></div>
</div>

<svg id="graph"></svg>

<script>
    // Global State
    let svg, g, zoom;
    let nodes = [], links = [];
    let currentLayout = 'LR'; // Left-to-Right by default
    let currentData = { nodes: [], edges: [] };

    // Highlight Colors Config
    const highlightColors = {
        1: { stroke: '#ff6b6b', fill: '#ffd93d' },
        2: { stroke: '#3cb371', fill: '#a8e6cf' },
        3: { stroke: '#da70d6', fill: '#ff9ff3' },
        4: { stroke: '#ee5a24', fill: '#feca57' },
        5: { stroke: '#0abde3', fill: '#48dbfb' },
        6: { stroke: '#e74c3c', fill: '#ff6348' },
        7: { stroke: '#636e72', fill: '#dfe6e9' },
        8: { stroke: '#6c5ce7', fill: '#a29bfe' },
        9: { stroke: '#e84393', fill: '#fd79a8' },
        10: { stroke: '#00cec9', fill: '#00b894' }
    };

    function getHighlightColor(group) {
        return highlightColors[group] ? highlightColors[group].stroke : '#ff6b6b';
    }

    function updateColorGroupsLegend(activeGroups) {
        const legendDiv = document.getElementById('colorGroupsLegend');
        if (activeGroups.size === 0) {
            legendDiv.innerHTML = '';
            return;
        }

        let html = '<div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; padding-top: 12px; border-top: 2px solid #ddd;">Color Groups:</div>';
        html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; font-size: 12px;">';

        Array.from(activeGroups.keys()).sort((a, b) => a - b).forEach(group => {
            const color = highlightColors[group];
            if (color) {
                html += `<div style="display: flex; align-items: center; gap: 6px;">
                        <div style="width: 14px; height: 14px; background: ${color.stroke}; border-radius: 50%;"></div>
                        <span style="font-weight: 500;">Group ${group}</span>
                    </div>`;
            }
        });

        html += '</div>';
        legendDiv.innerHTML = html;
    }

    function initGraph() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        svg = d3.select("#graph")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height]);

        g = svg.append("g");

        zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

        svg.call(zoom);

        // Define Arrow Markers
        const defs = svg.append("defs");
        const arrowTypes = ["default", "contains", "uses", "references", "inherits"];
        
        arrowTypes.forEach(type => {
            // Helper to create marker
            const createMarker = (id, color) => {
                defs.append("marker")
                    .attr("id", id)
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 9) // Adjusted for rectangles (puts arrow closer to box)
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                    .append("path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .attr("fill", color);
            };

            // Standard Colors
            let standardColor = "#999";
            if (type === "contains" || type === "inherits") standardColor = "#666";
            if (type === "uses") standardColor = "#aaa";
            
            createMarker(`arrow-${type}`, standardColor);

            // Colored markers for groups
            for (let i = 1; i <= 10; i++) {
                if (highlightColors[i]) {
                    createMarker(`arrow-${type}-highlight-${i}`, highlightColors[i].stroke);
                }
            }
        });
    }

    // --- MAIN RENDER FUNCTION (DAGRE TREE LAYOUT) ---
    function renderGraph(data) {
        currentData = data; // Store for redraw
        nodes = JSON.parse(JSON.stringify(data.nodes || [])); // Deep copy to prevent ref issues
        links = JSON.parse(JSON.stringify(data.edges || []));

        g.selectAll("*").remove(); // Clear canvas

        if (nodes.length === 0) {
            showError("No nodes found");
            return;
        }

        // 1. Setup Dagre
        const dagreGraph = new dagre.graphlib.Graph();
        dagreGraph.setGraph({ 
            rankdir: currentLayout, 
            nodesep: 40, 
            ranksep: 120,
            marginx: 50,
            marginy: 50
        });
        dagreGraph.setDefaultEdgeLabel(() => ({}));

        // 2. Define Node Dimensions
        const nodeWidth = 150;
        const nodeHeight = 45;

        nodes.forEach(node => {
            dagreGraph.setNode(node.id, { label: node.label, width: nodeWidth, height: nodeHeight });
        });

        links.forEach(link => {
            const source = typeof link.source === 'object' ? link.source.id : link.source;
            const target = typeof link.target === 'object' ? link.target.id : link.target;
            dagreGraph.setEdge(source, target);
        });

        // 3. Calculate Layout
        dagre.layout(dagreGraph);

        // 4. Map Coords back to data
        dagreGraph.nodes().forEach(nodeId => {
            const n = nodes.find(n => n.id === nodeId);
            const point = dagreGraph.node(nodeId);
            if (n) {
                n.x = point.x;
                n.y = point.y;
            }
        });

        // 5. Update Legend Stats
        const highlightGroups = new Map();
        nodes.filter(n => n.highlighted).forEach(n => highlightGroups.set(n.highlightGroup, 1));
        links.filter(l => l.highlighted).forEach(l => highlightGroups.set(l.highlightGroup, 1));
        updateColorGroupsLegend(highlightGroups);
        
        const highlightedCount = nodes.filter(n => n.highlighted).length;
        let statsHTML = `Nodes: ${nodes.length} | Edges: ${links.length}`;
        if (highlightedCount > 0) statsHTML += ` <span class="highlight-badge">${highlightedCount} highlighted</span>`;
        document.getElementById('stats').innerHTML = statsHTML;

        // 6. Draw Links (Curved lines)
        const lineGenerator = d3.line()
            .curve(d3.curveBasis) // Bezier curve
            .x(d => d.x)
            .y(d => d.y);

        const linkSelection = g.append("g")
            .selectAll("path")
            .data(links)
            .join("path")
            .attr("class", d => {
                let classes = `link ${d.type || 'default'}`;
                if (d.highlighted) classes += ` highlighted highlight-${d.highlightGroup}`;
                return classes;
            })
            .attr("marker-end", d => {
                const type = d.type || 'default';
                return d.highlighted ? `url(#arrow-${type}-highlight-${d.highlightGroup})` : `url(#arrow-${type})`;
            })
            .attr("d", d => {
                const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                const s = nodes.find(n => n.id === sourceId);
                const t = nodes.find(n => n.id === targetId);
                
                // Simple Bezier Logic: Start -> Midpoint -> End
                return lineGenerator([
                    {x: s.x, y: s.y},
                    {x: (s.x + t.x) / 2, y: s.y}, // Control Point 1
                    {x: (s.x + t.x) / 2, y: t.y}, // Control Point 2
                    {x: t.x, y: t.y}
                ]);
            });

        // 7. Draw Nodes (Groups with Rect + Text)
        const nodeSelection = g.append("g")
            .selectAll("g")
            .data(nodes)
            .join("g")
            .attr("class", d => {
                let classes = `node ${d.type || 'default'}`;
                if (d.highlighted) classes += ` highlighted highlight-${d.highlightGroup}`;
                return classes;
            })
            .attr("transform", d => `translate(${d.x},${d.y})`)
            .on("mouseenter", showTooltip)
            .on("mousemove", moveTooltip)
            .on("mouseleave", hideTooltip)
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        nodeSelection.append("rect")
            .attr("width", nodeWidth)
            .attr("height", nodeHeight)
            .attr("x", -nodeWidth / 2)
            .attr("y", -nodeHeight / 2);

        nodeSelection.append("text")
            .attr("class", "label")
            .text(d => {
                const len = 20;
                return d.label.length > len ? d.label.substring(0, len) + '...' : d.label;
            });

        centerGraph();
        clearError();
    }

    // --- DRAG FUNCTIONS (STATIC) ---
    function dragstarted(event, d) {
        d3.select(this).raise(); // Bring to front
        d3.select(this).select("rect").attr("stroke", "#333");
    }

    function dragged(event, d) {
        d.x = event.x;
        d.y = event.y;
        d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
        
        // Redraw connected links
        g.selectAll(".link").attr("d", l => {
            const sId = typeof l.source === 'object' ? l.source.id : l.source;
            const tId = typeof l.target === 'object' ? l.target.id : l.target;
            
            const s = nodes.find(n => n.id === sId);
            const t = nodes.find(n => n.id === tId);
            
            const lineGenerator = d3.line().curve(d3.curveBasis).x(p => p.x).y(p => p.y);
            return lineGenerator([
                {x: s.x, y: s.y},
                {x: (s.x + t.x) / 2, y: s.y},
                {x: (s.x + t.x) / 2, y: t.y},
                {x: t.x, y: t.y}
            ]);
        });
    }

    function dragended(event, d) {
        d3.select(this).select("rect").attr("stroke", null);
    }

    // --- UTILS ---
    function centerGraph() {
        if (!svg || !zoom || nodes.length === 0) return;
        const width = window.innerWidth;
        const height = window.innerHeight;

        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        nodes.forEach(n => {
            minX = Math.min(minX, n.x);
            maxX = Math.max(maxX, n.x);
            minY = Math.min(minY, n.y);
            maxY = Math.max(maxY, n.y);
        });

        const gW = maxX - minX + 200; // Add padding
        const gH = maxY - minY + 200;
        const scale = Math.min(width / gW, height / gH, 1);
        
        // Center calculation
        const x = (width - gW * scale) / 2 - minX * scale + 100 * scale;
        const y = (height - gH * scale) / 2 - minY * scale + 100 * scale;

        svg.transition().duration(750).call(
            zoom.transform, 
            d3.zoomIdentity.translate(x, y).scale(scale)
        );
    }

    function changeLayout() {
        const layouts = ['LR', 'TB', 'RL', 'BT'];
        const idx = layouts.indexOf(currentLayout);
        currentLayout = layouts[(idx + 1) % layouts.length];
        document.getElementById('layoutMode').textContent = currentLayout;
        renderGraph(currentData);
    }

    // --- TOOLTIP LOGIC (Unchanged mostly) ---
    let tooltip = null;
    function createTooltip() {
        if (!tooltip) tooltip = d3.select("body").append("div").attr("class", "tooltip").style("display", "none");
        return tooltip;
    }

    function showTooltip(event, d) {
        const tooltip = createTooltip();
        let html = `<div class="tooltip-title">${d.label}${d.highlighted ? ` <span class="highlight-badge" style="background: ${getHighlightColor(d.highlightGroup)}">GROUP ${d.highlightGroup}</span>` : ''}</div>`;
        
        if (d.fullPath && d.fullPath !== d.label) html += `<div style="font-size: 10px; color: #888; margin-bottom: 8px; font-family: monospace;">${d.fullPath}</div>`;
        html += `<div style="font-size: 11px; color: #666; margin-bottom: 8px;">Type: <strong>${d.type || 'node'}</strong></div>`;
        
        // ... (Include all other tooltip logic from previous file here - omitted for brevity but logic remains same) ...
        // Simplified for this output to key fields:
        if (d.brief) html += `<div class="tooltip-section"><div class="tooltip-section-title">Summary</div><div>${d.brief}</div></div>`;
        if (d.classes && d.classes.length) html += `<div class="tooltip-section"><div class="tooltip-section-title">Classes</div>${d.classes.map(c=>`<div class="tooltip-member">${c}</div>`).join('')}</div>`;
        
        tooltip.html(html).style("display", "block").style("left", (event.pageX + 15) + "px").style("top", (event.pageY + 15) + "px");
    }

    function moveTooltip(event) {
        if (tooltip) tooltip.style("left", (event.pageX + 15) + "px").style("top", (event.pageY + 15) + "px");
    }

    function hideTooltip() {
        if (tooltip) tooltip.style("display", "none");
    }

    // --- DATA LOADING ---
    function convertMCPToD3Format(data) {
        // ... (Same conversion logic as before) ...
        if (data.nodes && data.nodes.length > 0 && typeof data.nodes[0].highlighted === 'boolean') return data;
        
        const d3Data = { graphType: data.graphType || "classDiagram", nodes: [], edges: [] };
        if (data.nodes) {
            data.nodes.forEach(node => {
                let displayName = node.id;
                if (node.type === "file") displayName = node.id.split("/").pop();
                else if (node.id.includes("::")) displayName = node.id.split("::").pop();

                const d3Node = {
                    id: node.id, fullPath: node.id, label: displayName, type: node.type || "class",
                    highlighted: (node.highlight || 0) > 0, highlightGroup: node.highlight || 0,
                    metadata: node.metadata // Keep metadata for tooltip
                };
                // Copy helpful metadata props to top level for tooltip
                if(node.metadata) {
                    if(node.metadata.brief_summary) d3Node.brief = node.metadata.brief_summary;
                    if(node.metadata.classes) d3Node.classes = node.metadata.classes;
                }
                d3Data.nodes.push(d3Node);
            });
        }
        if (data.edges) {
            data.edges.forEach(edge => {
                d3Data.edges.push({
                    source: edge.source, target: edge.target,
                    type: edge.type || "uses", label: edge.label || "",
                    highlighted: (edge.highlight || 0) > 0, highlightGroup: edge.highlight || 0
                });
            });
        }
        return d3Data;
    }

    function loadJSON(content) {
        try {
            const data = JSON.parse(content);
            const d3Data = convertMCPToD3Format(data);
            renderGraph(d3Data);
        } catch (error) {
            showError(`Error parsing JSON: ${error.message}`);
        }
    }

    function showError(msg) { document.getElementById('error').innerHTML = `<div class="error">${msg}</div>`; }
    function clearError() { document.getElementById('error').innerHTML = ''; }

    // Drop Handler
    document.body.addEventListener('dragover', (e) => e.preventDefault());
    document.body.addEventListener('drop', (e) => {
        e.preventDefault();
        const file = e.dataTransfer.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => loadJSON(event.target.result);
            reader.readAsText(file);
        }
    });

    window.addEventListener('resize', () => {
        svg.attr("width", window.innerWidth).attr("height", window.innerHeight);
        renderGraph(currentData);
    });

    // Auto-load attempt
    const autoLoadPaths = ['../code_graph.json', 'test-graph.json'];
    async function tryAutoLoad() {
        for (const path of autoLoadPaths) {
            try {
                const response = await fetch(path);
                if (response.ok) {
                    loadJSON(await response.text());
                    return;
                }
            } catch (e) {}
        }
        document.getElementById('info').innerHTML = '<div>Drop a .json file to visualize</div><div id="stats"></div>';
    }

    initGraph();
    tryAutoLoad();
</script>
</body>
</html>